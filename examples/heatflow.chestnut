parallel Real heat(Real2d data, Integer timestep) {
  timestep = timestep / 10;
  Integer xmin = timestep % heat.width;
  Integer xmax = (timestep + 10) % heat.width;
  Integer ymin = timestep % heat.height;
  Integer ymax = (timestep + 10) % heat.height;

  if ((heat.x < xmax) && (heat.x > xmin) && (heat.y < ymax) && (heat.y > ymin)) {
    return 1;
  }
  return data.center;
}

parallel Real heat_flow(Real2d data, Real c0, Real c1) {
  Real new_data = c0*data.center;
  new_data = new_data + c1*(data.left + data.right + data.top + data.bottom);


  if (new_data > 1) {
    new_data = 1;
  } if (new_data < 0) {
    new_data = 0;
  }
  return new_data;
}

//sequential Real squared(Real value) {
//  return value*value;
//}

parallel Color convert_color(Real2d array) {
  Color output;

  if (array.center == 1) {
    output.red = output.blue = output.green = 255;
    output.alpha = 255;
  } else {
    output.red = array.center*255;
    output.green = 0;
    output.blue = 0;
    output.alpha = 255;
  }

  return output;
}

parallel Real set_to(Real value) {
  return value;
}

Real kappa = 0.2;
Real delta_t = 1;
Real delta_x = 1;

Real c0 = 1 - 4 * kappa * delta_t / delta_x;
Real c1 = kappa * delta_t / delta_x;

Real2d heat_data[1000,500] = :set_to(0);
Integer2d heat_display[1000,500];


Integer iteration = 0;
Integer iterations = 10000;
while (iteration < iterations) {
  heat_data = :heat_flow(heat_data, c0, c1);
  heat_data = :heat(heat_data, iteration);
  display(heat_data, convert_color);

  iteration = iteration + 1;
}



